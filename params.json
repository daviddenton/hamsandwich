{"body":"##Tutorial\r\n###Installation\r\n1. Download a binary package from here. The Zip distribution contains all of the Javadoc, dependencies and source code for the project.\r\n\r\nor:\r\n\r\n2. Check out the source code from here and build it manually. Prerequisites:\r\n\r\n- Java 1.6\r\n- Ant (we use v1.8)\r\n- JUnit no dependencies version: junit-dep-<version>.jar - (we use v4.8.1)\r\nSimply type ant or ant build at the command line.in the \"core\" folder\r\n\r\n###Getting Started\r\nIf you're not familiar with the concept of Matchers and why they're ace, then it's probably a good idea to start with the Hamcrest Tutorial.\r\n\r\nTo integrate HamSandwich? into your project, the project Jar and contents of the Lib directory are required as dependencies. Note that as an older, incompatible version of Hamcrest (v1.1) is currently bundled with JUnit as standard, there may be classpath clashes if the full JUnit Jar is used.\r\n\r\nSay we have an simple object:\r\n\r\n```java\r\npackage org.hamsandwich.example.wiki;\r\n\r\npublic class Person {\r\n\r\n    private final String name;\r\n    public final int age;\r\n\r\n    public Person(String name, int age) {\r\n        this.name = name;\r\n        this.age = age;\r\n    }\r\n\r\n    public String getName() {\r\n        return name;\r\n    }\r\n}\r\n```\r\n... and a test for that class:\r\n\r\n```java\r\npackage org.hamsandwich.example.wiki;\r\n\r\nimport org.junit.Test;\r\n\r\nimport static org.hamcrest.MatcherAssert.assertThat;\r\nimport static org.hamcrest.Matchers.*;\r\n\r\npublic class PersonTest {\r\n\r\n    @Test\r\n    public void detailsStoredProperly() throws Exception {\r\n        Person dave = new Person(\"Dave\", 33);\r\n        Person alan = new Person(\"Alan\", 65);\r\n\r\n        assertThat(dave.getName(), is(equalTo(\"Dave\")));\r\n        assertThat(dave.age+10, is(equalTo(43)));\r\n        assertThat(dave.age, is(lessThan(alan.age)));\r\n    }\r\n}\r\n```\r\n\r\nEach of the assertions needs to be declared on a separate line in the test. This approach does give us a nice stack trace if the test fails with the line number so you can easily determine which assertion failed, along with a message from the matcher indicating what went wrong.\r\n\r\nThe downside of this approach is that there is no way to easily group the various assertions into reusable modules, save for extracting a method which contains the 3 assertThat() calls, which would end up something like:\r\n\r\n```java\r\npackage org.hamsandwich.example.wiki;\r\n\r\nimport org.junit.Test;\r\n\r\nimport static org.hamcrest.MatcherAssert.assertThat;\r\nimport static org.hamcrest.Matchers.*;\r\n\r\npublic class PersonTest {\r\n\r\n    @Test\r\n    public void detailsStoredProperly() throws Exception {\r\n        Person dave = new Person(\"Dave\", 33);\r\n        Person alan = new Person(\"Alan\", 65);\r\n\r\n        assertThePersonDetailsAgainst(dave, alan, \"Dave\", 43);\r\n    }\r\n\r\n    private void assertThePersonDetailsAgainst(Person actual, Person elderPerson, String expectedName, int expectedAge) {\r\n        assertThat(actual.getName(), is(equalTo(expectedName)));\r\n        assertThat(actual.age+10, is(equalTo(expectedAge)));\r\n        assertThat(actual.age, is(lessThan(elderPerson.age)));\r\n    }\r\n}\r\n```\r\n\r\nThis is a quite ugly and ends up with all of the expected details being passed around, along with the object under test.\r\n\r\n###Alternatively...\r\nUsing a HamSandwich Matcher you can extract and group the common assertions, providing reuse in a Functional Style without hampering readability. To do so:\r\n\r\n1. Decide on the common conditions that you want to assert on. These are typically fields, but you can build up less granular, more complex Matchers by composition. In the above example, we will use the name and age fields of the Person class.\r\n\r\n2. Declare a factory method for each condition annotated with @HamSandwichFactory which will return a subclass of the AdaptingMatcher. This class requires the get() method to be implemented, which describes how to translate the input object (Person), into the output object (name -> String, age -> Integer). Alternatively, you can use a factory method to create a function replaying matcher (as done below for getName()). In this example we have grouped these methods onto a single utility class:\r\n\r\n```java\r\npackage org.hamsandwich.example.wiki;\r\n\r\nimport org.hamcrest.Matcher;\r\nimport org.hamsandwich.core.AdaptingMatcher;\r\nimport org.hamsandwich.core.CannotAdaptException;\r\nimport org.hamsandwich.core.HamSandwichFactory;\r\n\r\nimport static org.hamsandwich.core.ReplayMatcher.on;\r\nimport static org.hamsandwich.core.ReplayMatcher.replayMatcher;\r\n\r\npublic class PersonMatchers {\r\n\r\n    @HamSandwichFactory\r\n    public static Matcher<Person> name(Matcher<String>... nameMatchers) {\r\n        return replayMatcher(on(Person.class).getName(), nameMatchers);\r\n    }\r\n\r\n    @HamSandwichFactory\r\n    public static Matcher<Person> ageInADecade(Matcher<? super Integer>... ageMatchers) {\r\n        return new AdaptingMatcher<Person, Integer>(ageMatchers) {\r\n            @Override\r\n            public Integer get(Person in) throws CannotAdaptException {\r\n                return in.age + 10;\r\n            }\r\n        };\r\n    }\r\n}\r\n```\r\n\r\nNote that the generics definition above involving super definitions Matcher<Integer> is required at the moment because of an issue with the version (1.3RC1) of Hamcrest that ships with HamSandwich?. This should be fixed soon in v1.3 as soon as it goes gold. In addition, the generics used above can be omitted from the signatures of these methods if required or desired. However, doing so will generate compiler warnings in your IDE.\r\n\r\n3. You can now rewrite the test in order to use the above matchers:\r\n\r\n```java\r\npackage org.hamsandwich.example.wiki;\r\n\r\nimport org.junit.Test;\r\n\r\nimport static org.hamcrest.MatcherAssert.assertThat;\r\nimport static org.hamcrest.Matchers.*;\r\nimport static org.hamsandwich.example.wiki.PersonMatchers.ageInADecade;\r\nimport static org.hamsandwich.example.wiki.PersonMatchers.name;\r\n\r\npublic class PersonTest {\r\n\r\n    @Test\r\n    public void detailsStoredProperly() throws Exception {\r\n        Person dave = new Person(\"Dave\", 33);\r\n        Person alan = new Person(\"Alan\", 65);\r\n\r\n        assertThat(dave,\r\n                allOf(\r\n                        name(is(equalTo(\"Dave\"))),\r\n                        ageInADecade(is(equalTo(43)), is(lessThan(alan.age)))\r\n                )\r\n        );\r\n    }\r\n}\r\n```\r\n\r\nWe now have a single call to assertThat() passing in the dave instance, and have also combined the assertions for age into a single variable which itself can be extracted and reused.\r\n\r\n###\"But what about the knowing where the test failed?\", I hear you cry...\r\nWell, firstly, the original version of the test lets you know the exact line number of the assertion failure, but that is actually duplicate information - the message supplied by the matcher should give the actual reason that the test failed. Combining Matchers into a single assertThat() call removes the duplication, but retains the failure reason information by utilising the SelfDescribing feature of Hamcrest. The name of the condition (i.e. the name of the annotated Factory method) is used instead. So, if we change the test to deliberately fail:\r\n\r\n```java\r\npackage org.hamsandwich.example.wiki;\r\n\r\nimport org.junit.Ignore;\r\nimport org.junit.Test;\r\n\r\nimport static org.hamcrest.MatcherAssert.assertThat;\r\nimport static org.hamcrest.Matchers.*;\r\nimport static org.hamsandwich.example.wiki.PersonMatchers.ageInADecade;\r\nimport static org.hamsandwich.example.wiki.PersonMatchers.name;\r\n\r\npublic class PersonTest {\r\n\r\n    @Test\r\n    public void detailsStoredProperly() throws Exception {\r\n        Person dave = new Person(\"Dave\", 33);\r\n        Person alan = new Person(\"Alan\", 65);\r\n\r\n        assertThat(dave,\r\n                allOf(\r\n                        name(is(equalTo(\"Mark\"))),\r\n                        ageInADecade(is(equalTo(53)), is(lessThan(alan.age)))\r\n                )\r\n        );\r\n    }\r\n}\r\n```\r\n\r\n... it now fails with the error message:\r\n\r\n```java\r\njava.lang.AssertionError: \r\nExpected: ([Person where name (is \"Mark\")] and [a Person where ageInADecade (is <53> and is a value less than <65>)])\r\n     but: [Person where name (is \"Mark\")] is \"Mark\" was \"Dave\"\r\n...\r\n```\r\n\r\n###And Finally...\r\nIt is also possible (nay, desirable!) to use these Matchers in production code as a filtering mechanic and there is an example of this usage included in the Zip distribution. An interesting benefit of the Hamcrest SelfDescribing functionality is that these Matchers generate human-readable descriptions from the describeTo() and toString() methods.\r\n\r\nThe library will also hugely benefit from the introduction of *real* closures in Java8 (whenever that turns up), as the implementation of the get() method on AdaptingMatcher can be replaced by a closure passed into the constructor, thus cleaning up a lot of code in the Factory methods.\r\n\r\nHave a play. Let us know what you think.\r\n\r\n:)\r\n","note":"Don't delete this file! It's used internally to help with page regeneration.","tagline":"Too clever for it's own good","name":"Hamsandwich","google":""}